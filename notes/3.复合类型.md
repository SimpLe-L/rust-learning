## 字符串
```js
fn main() {
  let my_name = "Pascal";
  greet(my_name);  // error,因为greet需要String 类型的字符串，传入的是 &str 类型
}

fn greet(name: String) {
  println!("Hello, {}!", name);
}
```

1. 切片(左闭右开)
let s = String::from("hello");
let slice = &s[0..2];  // he 
let slice = &s[..2];   // he

let test = &s[..] //全部切片
let test = &s[2..] //第二位到最后

let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];

2. 字符串字面量是切片
let s = "Hello, world!"; // s 的类型是 &str
等价于：
let s: &str = "Hello, world!";

3. 类型转换
----&str 类型生成 String 类型：
String::from("hello,world")
"hello,world".to_string()

----String 类型转为 &str：
fn main() {
    let s = String::from("hello,world!");
    say_hello(&s);
    say_hello(&s[..]);
    say_hello(s.as_str());
}

fn say_hello(s: &str) {
    println!("{}",s);
}

4. 字符串操作
--push
```js
fn main() {
    let mut s = String::from("Hello ");
    s.push_str("rust");
    println!("追加字符串 push_str() -> {}", s);
    s.push('!');
    println!("追加字符 push() -> {}", s);
}
```

--insert
```js
fn main() {
    let mut s = String::from("Hello rust!");
    s.insert(5, ',');
    println!("插入字符 insert() -> {}", s);
    s.insert_str(6, " I like");
    println!("插入字符串 insert_str() -> {}", s);
}
```

--replace / replacen / replace_range
```js
// replace: 返回一个新的字符串
 fn main() {
    let string_replace = String::from("I like rust. Learning rust is my favorite!");
    let new_string_replace = string_replace.replace("rust", "RUST");
    dbg!(new_string_replace);
    // new_string_replace = "I like RUST. Learning RUST is my favorite!"
}

// replacen: 返回一个新的字符串，多了一个参数，第三个参数为替换次数
 fn main() {
    let string_replace = "I like rust. Learning rust is my favorite!";
    let new_string_replacen = string_replace.replacen("rust", "RUST", 1);
    dbg!(new_string_replacen);
    // new_string_replacen = "I like RUST. Learning rust is my favorite!"
}

// replace_range:只能用于String。操作原字符串，第一个参数是替换范围，第二个是新的字符串
 fn main() {
    let mut string_replace_range = String::from("I like rust!");
    string_replace_range.replace_range(7..8, "R");
    dbg!(string_replace_range);
    // string_replace_range = "I like Rust!"
}
```

--pop / remove / truncate / clear：仅适用于 String 类型
```js
// pop 操作原字符串，返回字符串的最后一个字符
let mut string_pop = String::from("rust pop 中文!");
let p1 = string_pop.pop();


// remove 操作原字符串，删除并返回字符串中指定位置的字符，要注意参数是不是合法的字符边界
fn main() {
    let mut string_remove = String::from("测试remove方法");
    println!(
        "string_remove 占 {} 个字节",
        std::mem::size_of_val(string_remove.as_str())
    );
    // 删除第一个汉字
    string_remove.remove(0);
    // 下面代码会发生错误
    // string_remove.remove(1);
    // 直接删除第二个汉字
    // string_remove.remove(3);
    dbg!(string_remove);
}

// truncate 操作原字符串，删除字符串中从指定位置开始到结尾的全部字符，要注意参数是不是合法的字符边界
fn main() {
    let mut string_truncate = String::from("测试truncate");
    string_truncate.truncate(3);
    dbg!(string_truncate);
}

// clear 操作原字符串，清空字符串
fn main() {
    let mut string_clear = String::from("string clear");
    string_clear.clear();
    dbg!(string_clear); // ""
}
```

--连接：使用 + 或者 += 连接字符串
```js
// 右边的参数必须为字符串的切片引用（Slice）类型
fn main() {
    let string_append = String::from("hello ");
    let string_rust = String::from("rust");
    // &string_rust会自动解引用为&str
    let result = string_append + &string_rust;
    let mut result = result + "!"; // `result + "!"` 中的 `result` 是不可变的
    result += "!!!";

    println!("连接字符串 + -> {}", result); //连接字符串 + -> hello rust!!!!
}

// format! 连接字符串
fn main() {
    let s1 = "hello";
    let s2 = String::from("rust");
    let s = format!("{} {}!", s1, s2);
    println!("{}", s); // hello rust!
}
```
--操作 UTF-8 字符串
```js
//Unicode 字符的方式遍历字符串，使用chars()
for c in "中国人".chars() {
    println!("{}", c);
}

//字节
for b in "中国人".bytes() {
    println!("{}", b);
}
```

## 元组
1. 多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的。
```js
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}

//匹配解构元组
let tup = (500, 6.4, 1);
let (x, y, z) = tup;
println!("The value of y is: {}", y);

//使用 . 访问元组
let x: (i32, f64, u8) = (500, 6.4, 1);
let five_hundred = x.0;
let six_point_four = x.1;

//实际使用
fn main() {
    let s1 = String::from("hello");
    let (s2, len) = calculate_length(s1);
    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() 返回字符串的长度
    (s, length)
}
```

## 结构体
1. 基本结构
```js
struct User {
  active: bool,
  username: String,
  email: String,
  sign_in_count: u64,
}
// 使用 user 结构体
let mut user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
// 访问字段，并修改，注意，需要mut关键字，而且不支持结构体内部某个字段是可变的
user1.email = String::from("anotheremail@example.com");

// 简化创建：
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}

//结构体更新
let user2 = User {
      email: String::from("another@example.com"),
      ..user1
  };
// 注意，此过程中，username发生了所有权转移，因为 bool 和 u64 类型就实现了 Copy 特征，active 和 sign_in_count只进行了拷贝
// user1内部的其他字段仍可继续使用
```

2. 元组结构体
```js
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);

// 例如 3D 点是 (x, y, z) 形式的坐标点，因此我们无需再为内部的字段逐一命名为：x, y, z。
```

3. 单元结构体
```js
struct AlwaysEqual;
let subject = AlwaysEqual;
// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征
impl SomeTrait for AlwaysEqual {}
```

4. 打印结构体信息
--#[derive(Debug)]
```js
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    println!("rect1 is {:?}", rect1);
    println!("rect1 is {:#?}", rect1);
    // dbg!(&rect1);
}
```

## 枚举
1. 基本使用
```js
enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}
let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds;
```

2. 数据信息关联枚举成员
```js
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move{x:1,y:1};
    let m3 = Message::ChangeColor(255,255,0);
}

//任何类型的数据都可以放入枚举成员中：例如字符串、数值、结构体甚至另一个枚举。
```

3. Option 枚举
```js
enum Option<T> {
    Some(T),
    None,
}
// 实际使用：查找用户demo
fn find_user_by_id(id: u32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

fn main() {
    let user = find_user_by_id(2);
    match user {
        Some(name) => println!("Found user: {}", name),
        None => println!("User not found"),
    }
}
```

## 数组
1. 静态数组
```js
let a = [1, 2, 3, 4, 5];
let a: [i32; 5] = [1, 2, 3, 4, 5]; // 长度为5的i32类型的数组
let a = [3; 5]; // 长度为5，全部用3填充

let first = a[0]
```

2. 数组元素为非基础类型
```js
let array = [String::from("rust is good!"); 8];
println!("{:#?}", array); // 报错，因为基本类型可以copy，复杂类型只能一个个创建

// 可以这样：
let array: [String; 8] = std::array::from_fn(|_i| String::from("rust is good!"));
println!("{:#?}", array);
```


```js
```