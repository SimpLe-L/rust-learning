## 所有权
1. 定义
Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)

2. 转移所有权
---------- 不转移所有权 ----------
let x = 5;
let y = x;

x y都是基本数据类型，自动拷贝，存在于栈中，没有发生所有权的转移
---------- 转移所有权 ----------
let s1 = String::from("hello");
let s2 = s1;

当 s1 被赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop 任何东西，这就是把所有权从 s1 转移给了 s2，s1 在被赋予 s2 后就马上失效了

3. 深拷贝
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);

4. 函数传值与返回
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作


## 引用和借用
1. 有了引用，不用频繁的进行所有权的转移
```js
fn main() {
    // let x = 5;
    // let y = &x;
    //  *y: 5
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
} // s 是对 String 的引用, 这里 s 离开了作用域，但因为它并不拥有引用值的所有权，所以无事发生
```

2. 可变引用
```js
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
注意：
同一作用域，特定数据只能有一个可变引用！！
可变引用与不可变引用不能同时存在
```js
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;
println!("{}, {}", r1, r2); //报错，同一作用域，特定数据只能有一个可变引用

let mut s = String::from("hello");
let r1 = &s; // 没问题
let r2 = &s; // 没问题
let r3 = &mut s; // 大问题
println!("{}, {}, and {}", r1, r2, r3);// 报错，可变引用与不可变引用不能同时存在
```
